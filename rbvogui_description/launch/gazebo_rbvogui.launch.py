import os

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, SetEnvironmentVariable, RegisterEventHandler, TimerAction, ExecuteProcess
from launch.event_handlers import OnProcessExit
from launch.substitutions import Command, LaunchConfiguration, PathJoinSubstitution, PythonExpression
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from launch_ros.parameter_descriptions import ParameterValue
from ament_index_python.packages import get_package_share_directory
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.actions import IncludeLaunchDescription
from launch.conditions import IfCondition

def generate_launch_description():
    declared_arguments = []
    
    # === PATHS FILES
    xacro_file = os.path.join(
        get_package_share_directory('rbvogui_description'),        "robots",
        "rbvogui_std.urdf.xacro"    )
    
    models_path = os.path.join(get_package_share_directory('rbvogui_description'), 'models')
    world_file = os.path.join(get_package_share_directory('rbvogui_description'), "worlds", "leonardo_race_field.sdf")
    config_path = os.path.join(get_package_share_directory('rbvogui_description'), 'config', 'robot_ackermann_control.yaml')
    
    # Robot description generated by xacro with launch-time arguments   
    robot_description_content = ParameterValue(
       Command(["xacro ", xacro_file, " command_interface:=", LaunchConfiguration("command_interface"), " traj:=" , LaunchConfiguration("traj")]),        
       value_type=str
    )
    robot_description = {"robot_description": robot_description_content}
    
  
    #  === SLAM PARAMETERS AND MAPS ===
    slam_mode = LaunchConfiguration('slam_mode')
    use_sim_time = LaunchConfiguration('use_sim_time')
    map_file = LaunchConfiguration('map_file')
    slam_params_file_mapping = LaunchConfiguration('slam_params_file_mapping')
    slam_params_file_localization = LaunchConfiguration('slam_params_file_localization')
    
    # Arguments for map and slam parameter files
    declare_map_file_cmd = DeclareLaunchArgument(
        'map_file',
        default_value=PathJoinSubstitution([
            FindPackageShare('rbvogui_description'), 'maps', 'mappa_bruno.yaml'
        ]),
        description='Path to the map YAML file to use during localization'
    )    

    slam_params_file_mapping_arg = DeclareLaunchArgument(
        'slam_params_file_mapping',
        default_value=PathJoinSubstitution(
            [FindPackageShare("rbvogui_description"), 'config', 'mapping.yaml']
        ),
        description='Full path to the ROS2 parameters file to use for the slam_toolbox node',
    )

    slam_params_file_localization_arg = DeclareLaunchArgument(
        'slam_params_file_localization',
        default_value=PathJoinSubstitution(
            [FindPackageShare("rbvogui_description"), 'config', 'localization.yaml']
        ),
        description='Full path to the ROS2 parameters file to use for the slam_toolbox node',
    )    
    
    slam_mode_arg = DeclareLaunchArgument(
        'slam_mode',
        default_value='mapping',
        description='SLAM mode: mapping or localization'
    )    
 
       
    use_sim_time_arg = DeclareLaunchArgument(
        'use_sim_time', default_value='true', description='Use simulation/Gazebo clock'
    )

    #  === DECLARED ARGUMENTS ===
    declared_arguments += [        
       DeclareLaunchArgument('config', default_value=config_path, description='YAML configuration file'), 
       DeclareLaunchArgument('command_interface', default_value="approximate_linearization", description="Controller type"),
       DeclareLaunchArgument('traj', default_value="cartesian", description='Desired trajectory type'),   
       declare_map_file_cmd, 
       slam_params_file_localization_arg,
       slam_params_file_mapping_arg,
       slam_mode_arg,
       use_sim_time_arg,  
    ]


    #  === SLAM NODES (mapping/localization, mutually exclusive) ===
    slam_node_mapping = Node(
        package='slam_toolbox',
        executable='async_slam_toolbox_node',
        name='slam_toolbox',
        parameters=[slam_params_file_mapping, {'use_sim_time': use_sim_time}],
        condition=IfCondition(PythonExpression(["'", slam_mode, "'", " == 'mapping'"])),
        output='screen'

    ) 
    
    slam_node_localization = Node(
        package='slam_toolbox',
        executable='localization_slam_toolbox_node',
        name='slam_toolbox',
        parameters=[slam_params_file_localization, {'use_sim_time': use_sim_time}, {'map_file_name': map_file}],
        condition=IfCondition(PythonExpression(["'", slam_mode, "'", " == 'localization'"])),
        output='screen'

    )      
    
    #  === TF AND STATIC TRANSFORMS ===
    # Publishes the dynamic odometry transform
    odom_tf = Node(
        package='rbvogui_description',
        executable='dynamic_tf_publisher',
        name='odom_tf',
        parameters=[{"use_sim_time": True}],
        output='screen'
    ) 
    
    # Static transform for lidar sensor
    laser_id_link_tf = Node(package='tf2_ros',
                     executable='static_transform_publisher',
                     name='lidar_staticTF',
                     output='log',
                     arguments=['0.0', '0.0', '0.5', '0.0', '0.0', '0.0', 'laser_frame', 'robot_base_link'],
                     parameters=[{"use_sim_time": True}]
    )      
   
    #  === CONTROLLERS SPAWNERS ===
    # Launches each controller in order after previous ones are ready
    joint_state_broadcaster_spawner = Node(
       package="controller_manager",
       executable="spawner",
       arguments=["joint_state_broadcaster", "--controller-manager", "/controller_manager"],
       output="screen"
    )
    
    steering_controller_spawner = Node(
       package="controller_manager",
       executable="spawner",
       arguments=["steering_controller","--controller-manager", "/controller_manager"],
       output="screen"
    )
    
    arm_controller_spawner = Node(
       package="controller_manager",
       executable="spawner",
       arguments=["ur5_arm_controller","--controller-manager", "/controller_manager"],
       output="screen"
    )    
    
    # Starts inactive, will be switched in runtime as needed
    arm_velocity_controller_spawner = Node(
       package="controller_manager",
       executable="spawner",
       arguments=["ur5_arm_velocity_controller","--controller-manager", "/controller_manager", "--inactive"],
       output="screen"
    )           
    
    #  === ROBOT SPAWNING IN GAZEBO ===
    # Set the initial pose (x, y, z, yaw) for the robot in Gazebo
    position = [0.0, 0.0, 0.1, 0]     
     
    gz_spawn_entity = Node(
        package='ros_gz_sim',
        executable='create',
        output='screen',
        arguments=[
            '-topic', 'robot_description',
            '-name', 'rbvogui',
            '-allow_renaming', 'true',
            '-x', str(position[0]),
            '-y', str(position[1]),
            '-z', str(position[2]),
            '-Y', str(position[3]),
            '--params-file', config_path
        ]
    ) 

    #  === CONTROLLER AND NODE STARTUP SEQUENCING ===
    delayed_slam_localization_spawner = RegisterEventHandler(
        OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[slam_node_localization]
        )
    )         
     
    delayed_slam_mapping_spawner = RegisterEventHandler(
        OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[slam_node_mapping]
        )
    )     
     
    delayed_joint_state_spawner = RegisterEventHandler(
        OnProcessExit(
            target_action=gz_spawn_entity,
            on_exit=[joint_state_broadcaster_spawner]
        )
    )
 
    delayed_arm_controller_spawner = RegisterEventHandler(
       OnProcessExit(
            target_action=joint_state_broadcaster_spawner,
            on_exit=[arm_controller_spawner]
        )
    ) 
  
    delayed_steering_controller_spawner = RegisterEventHandler(
        OnProcessExit(
            target_action=arm_controller_spawner,
            on_exit=[steering_controller_spawner]
        )
    )
    
    
    #   === STATE PUBLISHER NODES === 
    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[robot_description, {"use_sim_time": True}]
    )

    joint_state_publisher_node = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        parameters=[{"use_sim_time": True}]
    )
    
    #  === CUSTOM PLANNER NODE ===
    planner_node = Node(
        package='planner',
        executable='bicycle_tracker_node',
        name='bicycle_tracker_node',
        output='screen',
        remappings=[
            ("/robotnik_base_control/cmd_vel", "/cmd_vel")
        ],
        parameters=[{"wheels_distance": 1.0,
                     "command_interface": LaunchConfiguration("command_interface"),
                     "traj": LaunchConfiguration("traj") }]
    )

    #  === GAZEBO IGNITION SIMULATION LAUNCH === 
    declared_arguments.append(
        DeclareLaunchArgument(
            'gz_args',
            default_value=world_file,
            description='path to world file'
        )
    )

    gazebo_ignition = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('ros_gz_sim'),
                'launch',
                'gz_sim.launch.py'
            ])
        ]),
        launch_arguments={'gz_args': LaunchConfiguration('gz_args')}.items()
    )
    
    #  === BRIDGES (ros_gz_bridge) - Connect ROS <-> Ignition Gazebo topics ===
    bridge = Node(
        package='ros_gz_bridge',
        executable='parameter_bridge',
        arguments=['/cmd_vel@geometry_msgs/msg/Twist@ignition.msgs.Twist',
                   '/clock@rosgraph_msgs/msg/Clock[ignition.msgs.Clock',
                   '/model/rbvogui/tf@tf2_msgs/msg/TFMessage@ignition.msgs.Pose_V', 
                   '/model/rbvogui/odometry@nav_msgs/msg/Odometry@ignition.msgs.Odometry',
                   '/lidar@sensor_msgs/msg/LaserScan@ignition.msgs.LaserScan'
                   ],
        output='screen'
    )

    ign_clock_bridge = Node(
        package="ros_gz_bridge",
        executable="parameter_bridge",
        name="ros_gz_bridge",
        arguments=["/clock@rosgraph_msgs/msg/Clock[ignition.msgs.Clock"],
        remappings=[
            ("/tf", "tf"),
            ("/tf_static", "tf_static"),
        ],
        output="screen",
        namespace="fra2mo"
    )

    camera_view_node = Node(
    	package='ros_gz_bridge',
    	executable='parameter_bridge',
    	name='camera_view',
    	output='screen',
    	arguments=[
    	    '/camera@sensor_msgs/msg/Image@gz.msgs.Image',
            '/camera_info@sensor_msgs/msg/CameraInfo@gz.msgs.CameraInfo',
            '--ros-args', 
            '-r', '/camera:=/videocamera',
        ],
    )
      
    # Gazebo nodes list  
    ign = [gazebo_ignition, gz_spawn_entity]

    #  === MAIN NODES LIST === 
    nodes_to_start = [        
        robot_state_publisher_node,
        joint_state_publisher_node,
        odom_tf,
        laser_id_link_tf,
        *ign,
        bridge,
        camera_view_node,
        planner_node,
        ign_clock_bridge,
        arm_velocity_controller_spawner
        
    ]

    #  === RETURN LAUNCH DESCRIPTION === 
    return LaunchDescription([
        # Export resource paths for Gazebo and Ignition to find models
        SetEnvironmentVariable(
            name="GZ_SIM_RESOURCE_PATH",
            value=models_path + ':' + os.environ.get('GZ_SIM_RESOURCE_PATH', '')
        ),
        SetEnvironmentVariable(
            name="IGN_GAZEBO_RESOURCE_PATH",
    	    value=":".join(filter(None, [
                os.environ.get("IGN_GAZEBO_RESOURCE_PATH", ""),
                os.path.join(get_package_share_directory("ur_description")),
                os.path.join(get_package_share_directory("rbvogui_description"))
            ]))
            
        ),        
        *declared_arguments,
        *nodes_to_start,
        # Sequencing event handlers for correct launch order
        delayed_joint_state_spawner,
        delayed_arm_controller_spawner,                
        delayed_steering_controller_spawner,
        delayed_slam_mapping_spawner,
        delayed_slam_localization_spawner
      
    ])
